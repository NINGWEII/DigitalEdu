import java.util.Arrays;
public class notAlone {	
	public static void main(String[] args) {
		
//		1. ვთქვათ, რომ ელემენტი “მარტოა” მაშინ, თუ ამ ელემენტის წინა და
//		მომდევნო ელემენტები განსხვავებულია მისგან. დააბრუნეთ ისეთი მასივი,
//		სადაც ყოველი გადმოცემული რიცხვი (რომელიც მარტოა) ჩანაცვლდება მისი
//		მეზობელი რიცხვებიდან მაქსიმალურით. მაგალითად: notAlone([1, 2, 3]) -> [1, 3,
//		3];
//		notAlone([1, 2, 3, 2, 5, 2]) -> [1, 3, 3, 5, 5, 2];
//		notAlone([3, 4]) -> [3, 4];
		

		
		int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
		System.out.println("Original array: " + Arrays.toString(arr));
		for(int i = 0; i < arr.length; i++) {	
	   /* (1) ქვემოთ მოცემული if() კონდიცია უზრუნველჰყოფს, რომ მასივის პირველი და ბოლო ელემენტები არ შედარდეს 
	    *     არც წინა და არც მომდევნო ელემენტებს, რადგან პირველ ელემენტს წინა ელემენტი არ გააჩნია. 
	    *     ხოლო ბოლო ელემენტს არ გააჩნია მომდევნო ელემენტი. 
		* (2) ასევე, ეს კონდიცია უზრუნველჰყოფს, რომ ელემენტი 'მარტოა', ანუ არც წინა ელემენტის ტოლია 
		*     და არც მომდევნოსი;
		* (3) ასევე უზრუნველჰყოფს, რომ ელემენტის წინა და მომდევნო ელემენტები ერთმანეთის ტოლი არაა.				
		*/	
			if(   i == 0
			   || i == arr.length - 1 
			   || arr[i] == arr[i - 1] 
			   || arr[i] == arr[i + 1] 
			   || arr[i - 1] == arr[i + 1]) continue;	
			else if(arr[i - 1] > arr[i + 1]) arr[i] = arr[i - 1]; 
			else if(arr[i - 1] < arr[i + 1]) arr[i] = arr[i + 1];
		}
		
		System.out.println("New array       " + Arrays.toString(arr));
		
		// კოდი გამართულად არ მუშაობს ((

		  
			  
    }
}
		 